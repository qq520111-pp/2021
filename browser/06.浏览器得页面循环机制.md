## 浏览器和用户行为交互、运转页面等。

> 浏览器通过一个循环，**不断去读取消息队列中的任务**，而这些任务可以有很多地方存进来的。也就是涉及**消息队列**、**事件循环系统**等相关概念。

## 浏览器消息队列

队列遵循先进先出，和栈相反。也就意味着队列中并没有一些权重执行的决策，会出现前面执行过大时一直等待中。这里是通过引入宏任务、微任务去解决权重的问题。

消息队列的来源：渲染进程、网络进程、用户交互等会不断的添加任务。

## 事件循环系统

循环系统是执行在主线程上的，通过模拟一个循环不断去读取消息队列中的任务，里面的执行顺序大致是

消息队列 => 延迟队列 。时间粒度差异较大，因为消息队列中执行有可能过久会阻碍延迟队列的时间精准度。通过

微任务来解决.

## 微任务

**微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。**

微任务产生的时机和执行微任务队列的时机。

通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清

空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执

行队列中的微任务。**WHATWG 把执行微任务的时间点称为检查点**。


如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，

V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行

微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继

续执行。

## 页面使用单线程的缺点

上面讲述的就是页面线程的循环系统是如何工作的，那接下来，我们继续探讨页面线程的一

些特征。

通过上面的介绍，你应该清楚了，页面线程所有执行的任务都来自于消息队列。消息队列

是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会

被执行。鉴于这个属性，就有如下两个问题需要解决。

第一个问题是如何处理高优先级的任务。

不过这个模式有个问题，因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调

用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致**执行效率的**

**下降**。

如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监

控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。

这也就是说，如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的**执行效率**；

如果采用异步方式，又会影响到**监控的实时性**。

那该如何权衡**效率**和**实时性**呢？

针对这种情况，微任务就应用而生了，下面我们来看看微任务是如何权衡效率和实时性的。

通常我们把消息队列中的任务称为**宏任务**，每个宏任务中都包含了一个**微任务队列**，在执行

宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不

会影响到宏任务的继续执行，因此也就解决了执行效率的问题。